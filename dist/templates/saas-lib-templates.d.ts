/**
 * @fileoverview SaaS Application Templates
 * @description Complete file templates for SaaS functionality including auth, database, and payments
 * Templates are used by creators to generate production-ready SaaS applications
 */
export declare const authMiddlewareTemplate = "import { z } from 'zod';\nimport { TeamDataWithMembers, User } from '@/lib/db/schema';\nimport { getTeamForUser, getUser } from '@/lib/db/queries';\nimport { redirect } from 'next/navigation';\n\nexport type ActionState = {\n error?: string;\n success?: string;\n [key: string]: any; // This allows for additional properties\n};\n\ntype ValidatedActionFunction<S extends z.ZodType<any, any>, T> = (\n data: z.infer<S>,\n formData: FormData\n) => Promise<T>;\n\nexport function validatedAction<S extends z.ZodType<any, any>, T>(\n schema: S,\n action: ValidatedActionFunction<S, T>\n) {\n return async (prevState: ActionState, formData: FormData) => {\n const result = schema.safeParse(Object.fromEntries(formData));\n if (!result.success) {\n return { error: result.error.issues[0].message };\n }\n\n return action(result.data, formData);\n };\n}\n\ntype ValidatedActionWithUserFunction<S extends z.ZodType<any, any>, T> = (\n data: z.infer<S>,\n formData: FormData,\n user: User\n) => Promise<T>;\n\nexport function validatedActionWithUser<S extends z.ZodType<any, any>, T>(\n schema: S,\n action: ValidatedActionWithUserFunction<S, T>\n) {\n return async (prevState: ActionState, formData: FormData) => {\n const user = await getUser();\n if (!user) {\n throw new Error('User is not authenticated');\n }\n\n const result = schema.safeParse(Object.fromEntries(formData));\n if (!result.success) {\n return { error: result.error.issues[0].message };\n }\n\n return action(result.data, formData, user);\n };\n}\n\ntype TeamActionFunction<T> = (\n formData: FormData,\n team: TeamDataWithMembers\n) => Promise<T>;\n\nexport function withTeam<T>(action: TeamActionFunction<T>) {\n return async (formData: FormData) => {\n const user = await getUser();\n if (!user) {\n throw new Error('User is not authenticated');\n }\n\n const team = await getTeamForUser(user.id);\n if (!team) {\n throw new Error('Team not found for user');\n }\n\n return action(formData, team);\n };\n}";
export declare const authSessionTemplate = "import { compare, hash } from 'bcryptjs';\nimport { SignJWT, jwtVerify } from 'jose';\nimport { cookies } from 'next/headers';\nimport { NewUser } from '@/lib/db/schema';\n\nconst key = new TextEncoder().encode(process.env.AUTH_SECRET);\nconst SALT_ROUNDS = 10;\n\nexport async function hashPassword(password: string) {\n return hash(password, SALT_ROUNDS);\n}\n\nexport async function comparePasswords(\n plainTextPassword: string,\n hashedPassword: string\n) {\n return compare(plainTextPassword, hashedPassword);\n}\n\ntype SessionData = {\n user: { id: number };\n expires: string;\n};\n\nexport async function signToken(payload: SessionData) {\n return await new SignJWT(payload)\n .setProtectedHeader({ alg: 'HS256' })\n .setIssuedAt()\n .setExpirationTime('1 day from now')\n .sign(key);\n}\n\nexport async function verifyToken(input: string) {\n const { payload } = await jwtVerify(input, key, {\n algorithms: ['HS256'],\n });\n return payload as SessionData;\n}\n\nexport async function getSession() {\n const session = (await cookies()).get('session')?.value;\n if (!session) return null;\n return await verifyToken(session);\n}\n\nexport async function setSession(user: NewUser) {\n const expiresInOneDay = new Date(Date.now() + 24 * 60 * 60 * 1000);\n const session: SessionData = {\n user: { id: user.id! },\n expires: expiresInOneDay.toISOString(),\n };\n const encryptedSession = await signToken(session);\n (await cookies()).set('session', encryptedSession, {\n expires: expiresInOneDay,\n httpOnly: true,\n secure: true,\n sameSite: 'lax'\n });\n}";
export declare const dbDrizzleTemplate = "import { drizzle } from 'drizzle-orm/postgres-js';\nimport postgres from 'postgres';\nimport * as schema from './schema';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nif (!process.env.POSTGRES_URL) {\n throw new Error('POSTGRES_URL environment variable is not set');\n}\n\nexport const client = postgres(process.env.POSTGRES_URL);\nexport const db = drizzle(client, { schema });";
export declare const dbQueriesTemplate = "import { desc, and, eq, isNull } from 'drizzle-orm';\nimport { db } from './drizzle';\nimport { activityLogs, teamMembers, teams, users } from './schema';\nimport { cookies } from 'next/headers';\nimport { verifyToken } from '@/lib/auth/session';\n\nexport async function getUser() {\n const sessionCookie = (await cookies()).get('session');\n if (!sessionCookie || !sessionCookie.value) {\n return null;\n }\n\n const sessionData = await verifyToken(sessionCookie.value);\n if (\n !sessionData ||\n !sessionData.user ||\n typeof sessionData.user.id !== 'number'\n ) {\n return null;\n }\n\n if (new Date(sessionData.expires) < new Date()) {\n return null;\n }\n\n const user = await db\n .select()\n .from(users)\n .where(and(eq(users.id, sessionData.user.id), isNull(users.deletedAt)))\n .limit(1);\n\n if (user.length === 0) {\n return null;\n }\n\n return user[0];\n}\n\nexport async function getTeamForUser(userId: number) {\n // First get the team\n const teamResult = await db\n .select()\n .from(teams)\n .innerJoin(teamMembers, eq(teams.id, teamMembers.teamId))\n .where(eq(teamMembers.userId, userId))\n .limit(1);\n\n if (teamResult.length === 0) {\n return null;\n }\n\n const team = teamResult[0].teams;\n\n // Then get all team members for this team\n const membersResult = await db\n .select({\n id: teamMembers.id,\n teamId: teamMembers.teamId,\n userId: teamMembers.userId,\n role: teamMembers.role,\n createdAt: teamMembers.createdAt,\n updatedAt: teamMembers.updatedAt,\n userName: users.name,\n userEmail: users.email\n })\n .from(teamMembers)\n .innerJoin(users, eq(teamMembers.userId, users.id))\n .where(eq(teamMembers.teamId, team.id));\n\n return {\n ...team,\n teamMembers: membersResult.map(member => ({\n id: member.id,\n teamId: member.teamId,\n userId: member.userId,\n role: member.role,\n createdAt: member.createdAt,\n updatedAt: member.updatedAt,\n user: {\n id: member.userId,\n name: member.userName,\n email: member.userEmail\n }\n }))\n };\n}\n\nexport async function getTeamByStripeCustomerId(customerId: string) {\n const result = await db\n .select()\n .from(teams)\n .where(eq(teams.stripeCustomerId, customerId))\n .limit(1);\n\n return result.length > 0 ? result[0] : null;\n}\n\nexport async function updateTeamSubscription(\n teamId: number,\n subscriptionData: {\n stripeSubscriptionId: string | null;\n stripeProductId: string | null;\n planName: string | null;\n subscriptionStatus: string;\n }\n) {\n await db\n .update(teams)\n .set({\n ...subscriptionData,\n updatedAt: new Date()\n })\n .where(eq(teams.id, teamId));\n}";
export declare const dbSchemaTemplate = "import {\n  pgTable,\n  serial,\n  varchar,\n  text,\n  timestamp,\n  integer,\n} from 'drizzle-orm/pg-core';\nimport { relations } from 'drizzle-orm';\n\nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 100 }),\n  email: varchar('email', { length: 255 }).notNull().unique(),\n  passwordHash: text('password_hash').notNull(),\n  role: varchar('role', { length: 20 }).notNull().default('member'),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow(),\n  deletedAt: timestamp('deleted_at'),\n});\n\nexport const teams = pgTable('teams', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 100 }).notNull(),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow(),\n  stripeCustomerId: text('stripe_customer_id').unique(),\n  stripeSubscriptionId: text('stripe_subscription_id').unique(),\n  stripeProductId: text('stripe_product_id'),\n  planName: varchar('plan_name', { length: 50 }),\n  subscriptionStatus: varchar('subscription_status', { length: 20 }),\n});\n\nexport const teamMembers = pgTable('team_members', {\n  id: serial('id').primaryKey(),\n  teamId: integer('team_id').notNull().references(() => teams.id),\n  userId: integer('user_id').notNull().references(() => users.id),\n  role: varchar('role', { length: 20 }).notNull().default('member'),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow(),\n});\n\nexport const activityLogs = pgTable('activity_logs', {\n  id: serial('id').primaryKey(),\n  teamId: integer('team_id').references(() => teams.id),\n  userId: integer('user_id').references(() => users.id),\n  action: varchar('action').notNull(),\n  timestamp: timestamp('timestamp').notNull().defaultNow(),\n  ipAddress: varchar('ip_address', { length: 45 }),\n});\n\nexport enum ActivityType {\n  SIGN_UP = 'SIGN_UP',\n  SIGN_IN = 'SIGN_IN',\n  SIGN_OUT = 'SIGN_OUT',\n  UPDATE_PASSWORD = 'UPDATE_PASSWORD',\n  DELETE_ACCOUNT = 'DELETE_ACCOUNT',\n  UPDATE_ACCOUNT = 'UPDATE_ACCOUNT',\n  CREATE_TEAM = 'CREATE_TEAM',\n  REMOVE_TEAM_MEMBER = 'REMOVE_TEAM_MEMBER',\n  INVITE_TEAM_MEMBER = 'INVITE_TEAM_MEMBER',\n  ACCEPT_INVITATION = 'ACCEPT_INVITATION'\n}\n\nexport type User = typeof users.$inferSelect;\nexport type NewUser = typeof users.$inferInsert;\nexport type Team = typeof teams.$inferSelect;\nexport type NewTeam = typeof teams.$inferInsert;\nexport type TeamMember = typeof teamMembers.$inferSelect;\nexport type NewTeamMember = typeof teamMembers.$inferInsert;\nexport type ActivityLog = typeof activityLogs.$inferSelect;\nexport type NewActivityLog = typeof activityLogs.$inferInsert;\n\nexport type TeamDataWithMembers = Team & {\n  teamMembers: (TeamMember & {\n    user: Pick<User, 'id' | 'name' | 'email'>;\n  })[];\n};";
export declare const dbSeedTemplate = "import { stripe } from '../payments/stripe';\nimport { db } from './drizzle';\nimport { users, teams, teamMembers } from './schema';\nimport { hashPassword } from '@/lib/auth/session';\n\nasync function createStripeProducts() {\n console.log('Creating Stripe products and prices...');\n\n const baseProduct = await stripe.products.create({\n name: 'Base',\n description: 'Base subscription plan',\n });\n\n await stripe.prices.create({\n product: baseProduct.id,\n unit_amount: 800, // $8 in cents\n currency: 'usd',\n recurring: {\n interval: 'month',\n trial_period_days: 7,\n }\n });\n\n const plusProduct = await stripe.products.create({\n name: 'Plus',\n description: 'Plus subscription plan',\n });\n\n await stripe.prices.create({\n product: plusProduct.id,\n unit_amount: 1200, // $12 in cents\n currency: 'usd',\n recurring: {\n interval: 'month',\n trial_period_days: 7,\n }\n });\n\n console.log('Stripe products and prices created successfully.');\n}\n\nasync function seed() {\n const email = 'test@test.com';\n const password = 'admin123';\n const passwordHash = await hashPassword(password);\n\n const [user] = await db\n .insert(users)\n .values([{\n email: email,\n passwordHash: passwordHash,\n role: \"owner\",\n }])\n .returning();\n\n console.log('Initial user created.');\n\n const [team] = await db\n .insert(teams)\n .values({\n name: 'Test Team',\n })\n .returning();\n\n await db.insert(teamMembers).values({\n teamId: team.id,\n userId: user.id,\n role: 'owner',\n });\n\n await createStripeProducts();\n}\n\nseed().catch(console.error);";
export declare const dbSetupTemplate = "import { exec } from 'node:child_process';\nimport { promises as fs } from 'node:fs';\nimport { promisify } from 'node:util';\nimport readline from 'node:readline';\nimport crypto from 'node:crypto';\nimport path from 'node:path';\nimport os from 'node:os';\n\nconst execAsync = promisify(exec);\n\nfunction question(query: string): Promise<string> {\n const rl = readline.createInterface({\n input: process.stdin,\n output: process.stdout,\n });\n\n return new Promise((resolve) => \n rl.question(query, (ans) => {\n rl.close();\n resolve(ans);\n })\n );\n}\n\nasync function checkStripeCLI() {\n console.log(\n 'Step 1: Checking if Stripe CLI is installed and authenticated...'\n );\n try {\n await execAsync('stripe --version');\n console.log('Stripe CLI is installed.');\n\n try {\n await execAsync('stripe config --list');\n console.log('Stripe CLI is authenticated.');\n } catch (error) {\n console.log(\n 'Stripe CLI is not authenticated or the authentication has expired.'\n );\n console.log('Please run: stripe login');\n const answer = await question(\n 'Have you completed the authentication? (y/n): '\n );\n if (answer.toLowerCase() !== 'y') {\n console.log(\n 'Please authenticate with Stripe CLI and run this script again.'\n );\n process.exit(1);\n }\n\n try {\n await execAsync('stripe config --list');\n console.log('Stripe CLI authentication confirmed.');\n } catch (error) {\n console.error(\n 'Failed to verify Stripe CLI authentication. Please try again.'\n );\n process.exit(1);\n }\n }\n } catch (error) {\n console.error(\n 'Stripe CLI is not installed. Please visit https://stripe.com/docs/stripe-cli and install it first.'\n );\n process.exit(1);\n }\n}\n\ncheckStripeCLI().catch(console.error);";
export declare const paymentsActionsTemplate = "'use server';\n\nimport { redirect } from 'next/navigation';\nimport { createCheckoutSession, createCustomerPortalSession } from './stripe';\nimport { withTeam } from '@/lib/auth/middleware';\n\nexport const checkoutAction = withTeam(async (formData, team) => {\n const priceId = formData.get('priceId') as string;\n await createCheckoutSession({ team: team, priceId });\n});\n\nexport const customerPortalAction = withTeam(async (_, team) => {\n const portalSession = await createCustomerPortalSession(team);\n redirect(portalSession.url);\n});";
export declare const paymentsStripeTemplate = "import Stripe from 'stripe';\nimport { redirect } from 'next/navigation';\nimport { Team } from '@/lib/db/schema';\nimport {\n getTeamByStripeCustomerId,\n getUser,\n updateTeamSubscription\n} from '@/lib/db/queries';\n\nexport const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n apiVersion: '2025-08-27.basil'\n});\n\nexport async function createCheckoutSession({\n team,\n priceId\n}: {\n team: Team | null;\n priceId: string;\n}) {\n const user = await getUser();\n\n if (!team || !user) {\n redirect(`/sign-up?redirect=checkout&priceId=${priceId}`);\n }\n\n const session = await stripe.checkout.sessions.create({\n payment_method_types: ['card'],\n line_items: [\n {\n price: priceId,\n quantity: 1\n }\n ],\n mode: 'subscription',\n success_url: `${process.env.BASE_URL}/api/stripe/checkout?session_id={CHECKOUT_SESSION_ID}`,\n cancel_url: `${process.env.BASE_URL}/pricing`,\n customer: team.stripeCustomerId || undefined,\n client_reference_id: user.id.toString(),\n allow_promotion_codes: true,\n subscription_data: {\n trial_period_days: 14\n }\n });\n\n redirect(session.url!);\n}\n\nexport async function createCustomerPortalSession(team: Team) {\n if (!team.stripeCustomerId || !team.stripeProductId) {\n redirect('/pricing');\n }\n\n let configuration: Stripe.BillingPortal.Configuration;\n const configurations = await stripe.billingPortal.configurations.list();\n\n if (configurations.data.length > 0) {\n configuration = configurations.data[0];\n } else {\n configuration = await stripe.billingPortal.configurations.create({\n business_profile: {\n headline: 'Manage your subscription',\n },\n features: {\n subscription_update: {\n enabled: true,\n default_allowed_updates: ['price'],\n proration_behavior: 'create_prorations',\n },\n },\n });\n }\n\n const portalSession = await stripe.billingPortal.sessions.create({\n customer: team.stripeCustomerId,\n return_url: `${process.env.BASE_URL}/pricing`,\n configuration: configuration.id,\n });\n\n return portalSession;\n}";
//# sourceMappingURL=saas-lib-templates.d.ts.map